using LightValidation.SourceGenerator.Models;
using Microsoft.CodeAnalysis;
using System.Globalization;

namespace LightValidation.SourceGenerator.Internal;

internal interface IExtensionMethodGenerator
{
    void Generate(in SourceProductionContext context, in MethodInfo info);
}

internal sealed class ExtensionMethodGenerator : IExtensionMethodGenerator
{
    private static readonly string AssemblyVersion = System.Reflection.Assembly
        .GetExecutingAssembly().GetName().Version.ToString();

    private const string ExtensionsClassFormat =
@"#nullable enable
// <auto-generated>
//     This code was generated by the LightValidation source generator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>

using LightValidation.Extensions;

namespace {0};

[System.CodeDom.Compiler.GeneratedCodeAttribute(""LightValidation.SourceGenerator"", ""{1}"")]
{2} static class {3}Extensions
{{
{4}
}}
";

    private const string ExtensionMethodFormat =
@"    public static LightValidation.Abstractions.Build.IRuleConfiguration<{0}, {1}, {2}{3}> {4}{3}(
        this LightValidation.Abstractions.Build.IRuleChainBuilder<{0}, {5}> ruleChainBuilder{6}){7}
    {{
        System.ArgumentNullException.ThrowIfNull(ruleChainBuilder);

        return ruleChainBuilder.{8}(new {2}{3}({9}))!;
    }}";

    private const string ConstraintsFormat =
@"
        {0}";

    private const string ExtensionMethodsDelimiter =
@"

";

    private const char NullableReferenceTypeModifier = '?';
    private const string MethodParametersFormat = ", {0}";
    private const string FullNameDelimiter = ".";
    private const string FilenameFormat = "{0}.g.cs";

    public void Generate(in SourceProductionContext context, in MethodInfo info)
    {
        var className = info.ClassInfo.FullName.Replace(FullNameDelimiter, string.Empty);
        var extensionMethods = GenerateExtensionMethods(info);

        context.CancellationToken.ThrowIfCancellationRequested();

        var sourceCode = string.Format(
            CultureInfo.InvariantCulture,
            ExtensionsClassFormat,
            info.AttributeInfo.Namespace,       // 0
            AssemblyVersion,                    // 1
            info.AttributeInfo.AccessModifier,  // 2
            className,                          // 3
            extensionMethods);                  // 4

        var filename = string.Format(CultureInfo.InvariantCulture, FilenameFormat, className);

        context.AddSource(filename, sourceCode);
    }

    private static string GenerateExtensionMethods(in MethodInfo info)
    {
        var constructorInfosLength = info.ConstructorInfos.Length;
        if (constructorInfosLength == 1)
        {
            return GenerateExtensionMethod(info, info.ConstructorInfos[0]);
        }

        var methods = new string[constructorInfosLength];
        for (var i = 0; i < constructorInfosLength; i++)
        {
            methods[i] = GenerateExtensionMethod(info, info.ConstructorInfos[i]);
        }

        return string.Join(ExtensionMethodsDelimiter, methods);
    }

    private static string GenerateExtensionMethod(in MethodInfo methodInfo, in ConstructorInfo constructorInfo)
    {
        var outputPropertyTypeSource = GetOutputPropertyTypeSource(methodInfo.InterfaceInfo);
        var methodParameters = constructorInfo.ParametersSource.FormatIfNotEmpty(MethodParametersFormat);
        var constraints = methodInfo.ClassInfo.ConstraintsSource.FormatIfNotEmpty(ConstraintsFormat);

        return string.Format(
            CultureInfo.InvariantCulture,
            ExtensionMethodFormat,
            methodInfo.InterfaceInfo.EntityTypeSource,    // 0
            outputPropertyTypeSource,                     // 1
            methodInfo.ClassInfo.FullName,                // 2 
            methodInfo.ClassInfo.GenericParametersSource, // 3
            methodInfo.AttributeInfo.MethodName,          // 4
            methodInfo.InterfaceInfo.PropertyTypeSource,  // 5
            methodParameters,                             // 6
            constraints,                                  // 7
            methodInfo.InterfaceInfo.RuleChainMethod,     // 8
            constructorInfo.ArgumentsSource);  // 9
    }

    private static string GetOutputPropertyTypeSource(in InterfaceInfo info)
    {
        if (!info.HasNullablePropertyTypeModifier)
        {
            return info.PropertyTypeSource;
        }

        return info.PropertyTypeSource.TrimEnd(NullableReferenceTypeModifier);
    }
}
