using LightValidation.SourceGenerator.Models;
using Microsoft.CodeAnalysis;
using System.Globalization;

namespace LightValidation.SourceGenerator.Internal;

internal interface IExtensionMethodGenerator
{
    void Generate(in SourceProductionContext context, in MethodInfo method);
}

internal sealed class ExtensionMethodGenerator : IExtensionMethodGenerator
{
    private static readonly string AssemblyVersion = System.Reflection.Assembly
        .GetExecutingAssembly().GetName().Version.ToString();

    private const string ExtensionsClassFormat =
@"#nullable enable
// <auto-generated>
//     This code was generated by the LightValidation source generator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>

using LightValidation.Extensions;

namespace {0};

[System.CodeDom.Compiler.GeneratedCodeAttribute(""LightValidation.SourceGenerator"", ""{1}"")]
{2} static class {3}Extensions
{{
{4}
}}
";

    private const string ExtensionMethodFormat =
@"    public static LightValidation.Abstractions.Build.IRuleConfiguration<{0}, {1}, {2}{3}> {4}{3}(
        this LightValidation.Abstractions.Build.IRuleChainBuilder<{0}, {5}> ruleChainBuilder{6}){7}
    {{
        System.ArgumentNullException.ThrowIfNull(ruleChainBuilder);

        return ruleChainBuilder.{8}(new {2}{3}({9}))!;
    }}";

    private const string ConstraintsFormat =
@"
        {0}";

    private const string ExtensionMethodsDelimiter =
@"

";

    private const char NullableReferenceTypeModifier = '?';
    private const string MethodParametersFormat = ", {0}";
    private const string FullNameDelimiter = ".";
    private const string FilenameFormat = "{0}.g.cs";

    public void Generate(in SourceProductionContext context, in MethodInfo method)
    {
        var className = method.Class.FullName.Replace(FullNameDelimiter, string.Empty);
        var extensionMethods = GenerateExtensionMethods(method);

        context.CancellationToken.ThrowIfCancellationRequested();

        var sourceCode = string.Format(
            CultureInfo.InvariantCulture,
            ExtensionsClassFormat,
            method.Attribute.Namespace,      // 0
            AssemblyVersion,                 // 1
            method.Attribute.AccessModifier, // 2
            className,                       // 3
            extensionMethods);               // 4

        var filename = string.Format(CultureInfo.InvariantCulture, FilenameFormat, className);

        context.AddSource(filename, sourceCode);
    }

    private static string GenerateExtensionMethods(in MethodInfo method)
    {
        var constructorCount = method.Constructors.Length;
        if (constructorCount == 1)
        {
            return GenerateExtensionMethod(method, method.Constructors[0]);
        }

        var methods = new string[constructorCount];
        for (var i = 0; i < constructorCount; i++)
        {
            methods[i] = GenerateExtensionMethod(method, method.Constructors[i]);
        }

        return string.Join(ExtensionMethodsDelimiter, methods);
    }

    private static string GenerateExtensionMethod(in MethodInfo method, in ConstructorInfo constructor)
    {
        var outputPropertyTypeSource = GetOutputPropertyTypeSource(
            method.Interface, method.Attribute.SavePropertyNullability);

        var methodParameters = constructor.ParametersSource.FormatIfNotEmpty(MethodParametersFormat);
        var constraints = method.Class.ConstraintsSource.FormatIfNotEmpty(ConstraintsFormat);

        return string.Format(
            CultureInfo.InvariantCulture,
            ExtensionMethodFormat,
            method.Interface.EntityTypeSource,    // 0
            outputPropertyTypeSource,             // 1
            method.Class.FullName,                // 2 
            method.Class.GenericParametersSource, // 3
            method.Attribute.MethodName,          // 4
            method.Interface.PropertyTypeSource,  // 5
            methodParameters,                     // 6
            constraints,                          // 7
            method.Interface.RuleChainMethod,     // 8
            constructor.ArgumentsSource);         // 9
    }

    private static string GetOutputPropertyTypeSource(in InterfaceInfo @interface, bool savePropertyNullability)
    {
        if (!@interface.HasNullablePropertyTypeModifier || savePropertyNullability)
        {
            return @interface.PropertyTypeSource;
        }

        return @interface.PropertyTypeSource.TrimEnd(NullableReferenceTypeModifier);
    }
}
